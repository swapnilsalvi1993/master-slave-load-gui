# -*- coding: utf-8 -*-
"""
Created on Wed Nov 26 12:26:05 2025

@author: ssalvi
"""

import tkinter as tk
from tkinter import filedialog, ttk, colorchooser, messagebox
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.ticker import MultipleLocator
from itertools import cycle
import json
from datetime import datetime
import io
import os

DEBOUNCE_MS = 1000  # debounce interval for live preview (milliseconds)


class ScrollableFrame:
    def __init__(self, master, width=None, height=None):
        self.container = ttk.Frame(master)
        self.canvas = tk.Canvas(self.container, borderwidth=0, highlightthickness=0)
        self.v_scroll = ttk.Scrollbar(self.container, orient="vertical", command=self.canvas.yview)
        self.h_scroll = ttk.Scrollbar(self.container, orient="horizontal", command=self.canvas.xview)
        self.canvas.configure(yscrollcommand=self.v_scroll.set, xscrollcommand=self.h_scroll.set)
        self.v_scroll.pack(side="right", fill="y")
        self.h_scroll.pack(side="bottom", fill="x")
        self.canvas.pack(side="left", fill="both", expand=True)
        self.inner = ttk.Frame(self.canvas)
        self.window_id = self.canvas.create_window((0,0), window=self.inner, anchor="nw")
        if width:
            self.container.config(width=width)
            self.canvas.config(width=width)
        if height:
            self.container.config(height=height)
            self.canvas.config(height=height)
        self.inner.bind("<Configure>", lambda e: self._on_frame_configure())
        self.canvas.bind("<Configure>", lambda e: self._on_canvas_configure())
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel, add="+")

    def pack(self, **kwargs): self.container.pack(**kwargs)
    def grid(self, **kwargs): self.container.grid(**kwargs)
    def place(self, **kwargs): self.container.place(**kwargs)

    def _on_frame_configure(self):
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def _on_canvas_configure(self):
        canvas_w = self.canvas.winfo_width()
        try:
            self.canvas.itemconfig(self.window_id, width=canvas_w)
        except Exception:
            pass

    def _on_mousewheel(self, event):
        if self.canvas.winfo_height() < self.inner.winfo_height():
            self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        else:
            if self.canvas.winfo_width() < self.inner.winfo_width():
                self.canvas.xview_scroll(int(-1*(event.delta/120)), "units")


class CSVPlotter:
    def __init__(self, root):
        self.root = root
        self.root.title("Interactive CSV Plotter")
        self.df = None

        # per-channel frames
        self.line_properties_frames = []
        self.right_line_properties_frames = []
        self.right2_line_properties_frames = []

        # per-channel persistent property maps keyed by column name
        self.left_channel_props = {}
        self.right_channel_props = {}
        self.right2_channel_props = {}

        # store detected header line index from PEC fallback (None if not set)
        self.detected_header_line_index = None

        # color cycles
        self.color_cycle = cycle(plt.rcParams['axes.prop_cycle'].by_key()['color'])
        self.right_color_cycle = cycle(plt.rcParams['axes.prop_cycle'].by_key()['color'])
        self.right2_color_cycle = cycle(plt.rcParams['axes.prop_cycle'].by_key()['color'])

        # Default plot size set to 12x8 inches
        self.default_plot_width = 12.0
        self.default_plot_height = 8.0

        # handle for debounced preview scheduling
        self._preview_after_id = None
        # cancel flag to request stop of ongoing preview
        self._preview_cancel_requested = False

        # Live preview toggle
        self.live_preview_var = tk.BooleanVar(value=True)

        # Explicit preview request flag (so preview_plot knows whether to bypass downsampling)
        self._explicit_preview_request = False

        # Downsample live preview toggle and limit
        self.downsample_live_var = tk.BooleanVar(value=True)
        self.max_preview_points = tk.IntVar(value=5000)  # max points per series for live preview

        # Global marker size (applies to all plotted markers)
        self.marker_size = tk.DoubleVar(value=6.0)

        # Global line width (replaces per-channel width)
        self.global_line_width = tk.DoubleVar(value=1.0)

        # Axis colors: axis spine/ticks/label color for each axis (marker colors moved to per-line)
        self.left_axis_color = tk.StringVar(value="#000000")
        self.right_axis_color = tk.StringVar(value="#1f77b4")   # default matplotlib blue
        self.right2_axis_color = tk.StringVar(value="#d62728")  # default matplotlib red

        # Right2 axis position relative to right axis
        self.right2_pos = tk.DoubleVar(value=1.2)

        self.create_widgets()

    def create_widgets(self):
        # Top-level root resizing behavior
        self.root.rowconfigure(0, weight=1)
        self.root.columnconfigure(0, weight=1)

        # Container frame
        container = ttk.Frame(self.root)
        container.grid(row=0, column=0, sticky="nsew")
        container.columnconfigure(0, weight=3)  # left column heavier
        container.columnconfigure(1, weight=2)  # right column lighter but sizable
        container.rowconfigure(0, weight=1)

        # Left column: controls inside a scrollable frame (wider)
        left_wrap = ScrollableFrame(container)
        left_wrap.container.grid(row=0, column=0, sticky="nsew", padx=(8,4), pady=8)
        self.main_frame = left_wrap.inner  # widgets go into this inner frame
        # Ensure main_frame expands vertically
        self.main_frame.columnconfigure(0, weight=1)

        # Right column: preview + save inside a scrollable frame
        right_wrap = ScrollableFrame(container)
        right_wrap.container.grid(row=0, column=1, sticky="nsew", padx=(4,8), pady=8)
        self.preview_parent = right_wrap.inner

        # --- CSV File Selection (left column) ---
        csv_frame = ttk.LabelFrame(self.main_frame, text="CSV File Selection")
        csv_frame.pack(pady=5, fill="x")
        ttk.Label(csv_frame, text="CSV File:").pack(side="left")
        self.file_entry = ttk.Entry(csv_frame, width=48)
        self.file_entry.pack(side="left", padx=5, fill="x", expand=True)
        ttk.Button(csv_frame, text="Browse", command=self.browse_file).pack(side="left", padx=4)
        ttk.Button(csv_frame, text="Reset CSV Section", command=self.reset_csv).pack(side="left", padx=4)

        # --- Axis Selection (Left Y-axis) (left column) ---
        col_frame = ttk.LabelFrame(self.main_frame, text="Left Y-axis Selection")
        col_frame.pack(pady=5, fill="x")
        # allow space for listbox and its individual scrollbar
        col_frame.columnconfigure(1, weight=1)
        ttk.Label(col_frame, text="X-axis:").grid(row=0, column=0, sticky="w")
        self.x_combo = ttk.Combobox(col_frame, state="readonly")
        self.x_combo.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.x_combo.bind("<<ComboboxSelected>>", lambda e: self.schedule_preview())

        ttk.Label(col_frame, text="Y-axis:").grid(row=1, column=0, sticky="nw")
        # create the listbox
        self.y_listbox = tk.Listbox(col_frame, selectmode="multiple", height=10, exportselection=False)
        self.y_listbox.grid(row=1, column=1, padx=(5,2), pady=2, sticky="nsew")
        # create an individual vertical scrollbar (slider) for this listbox
        self.y_listbox_scroll = ttk.Scrollbar(col_frame, orient="vertical", command=self.y_listbox.yview)
        self.y_listbox_scroll.grid(row=1, column=2, sticky="ns", padx=(0,4), pady=2)
        self.y_listbox.configure(yscrollcommand=self.y_listbox_scroll.set)
        self.y_listbox.bind("<<ListboxSelect>>", lambda e: self.update_line_properties())

        # Select All button for left Y-axis (user request)
        select_all_btn = ttk.Button(col_frame, text="Select All", command=self.select_all_left)
        select_all_btn.grid(row=2, column=1, sticky="w", padx=4, pady=(4,2))

        # Move Up / Move Down for left selection
        move_up_btn = ttk.Button(col_frame, text="Move Up", command=lambda: self.move_selected_in_listbox(self.y_listbox, direction=-1))
        move_up_btn.grid(row=2, column=1, sticky="e", padx=(0,80), pady=(4,2))
        move_down_btn = ttk.Button(col_frame, text="Move Down", command=lambda: self.move_selected_in_listbox(self.y_listbox, direction=1))
        move_down_btn.grid(row=2, column=1, sticky="e", padx=(0,4), pady=(4,2))

        ttk.Button(col_frame, text="Reset Axis Section", command=self.reset_axis).grid(row=3, column=1, sticky="e", pady=2, padx=4)

        # --- Line Properties Section (Left Y-axis) (left column) ---
        self.line_prop_frame = ttk.LabelFrame(self.main_frame, text="Per-Channel Label + Properties (Left Y-axis)")
        self.line_prop_frame.pack(pady=5, fill="both")
        ttk.Button(self.line_prop_frame, text="Reset Line Properties", command=self.reset_line_properties).pack(anchor="e", padx=4, pady=2)

        # --- Right Y-axis 1 Selection (left column) ---
        right_col_frame = ttk.LabelFrame(self.main_frame, text="Right Y-axis 1 Selection")
        right_col_frame.pack(pady=5, fill="x")
        right_col_frame.columnconfigure(1, weight=1)
        ttk.Label(right_col_frame, text="Right Y-axis 1 Columns:").grid(row=0, column=0, sticky="nw")
        self.right_y_listbox = tk.Listbox(right_col_frame, selectmode="multiple", height=5, exportselection=False)
        self.right_y_listbox.grid(row=0, column=1, padx=(5,2), pady=2, sticky="nsew")
        self.right_y_listbox_scroll = ttk.Scrollbar(right_col_frame, orient="vertical", command=self.right_y_listbox.yview)
        self.right_y_listbox_scroll.grid(row=0, column=2, sticky="ns", padx=(0,4), pady=2)
        self.right_y_listbox.configure(yscrollcommand=self.right_y_listbox_scroll.set)
        self.right_y_listbox.bind("<<ListboxSelect>>", lambda e: self.update_right_line_properties())

        # Move Up / Move Down for right1 selection
        move_up_btn_r1 = ttk.Button(right_col_frame, text="Move Up", command=lambda: self.move_selected_in_listbox(self.right_y_listbox, direction=-1))
        move_up_btn_r1.grid(row=1, column=1, sticky="w", padx=4, pady=(4,2))
        move_down_btn_r1 = ttk.Button(right_col_frame, text="Move Down", command=lambda: self.move_selected_in_listbox(self.right_y_listbox, direction=1))
        move_down_btn_r1.grid(row=1, column=1, sticky="e", padx=4, pady=(4,2))

        ttk.Button(right_col_frame, text="Reset Right Y-axis 1 Section", command=self.reset_right_axis).grid(row=2, column=1, sticky="e", pady=2, padx=4)

        # --- Line Properties Section (Right Y-axis 1) (left column) ---
        self.right_line_prop_frame = ttk.LabelFrame(self.main_frame, text="Per-Channel Label + Properties (Right Y-axis 1)")
        self.right_line_prop_frame.pack(pady=5, fill="both")
        ttk.Button(self.right_line_prop_frame, text="Reset Right Line Properties", command=self.reset_right_line_properties).pack(anchor="e", padx=4, pady=2)

        # --- Right Y-axis 2 Selection (left column) ---
        right2_col_frame = ttk.LabelFrame(self.main_frame, text="Right Y-axis 2 Selection")
        right2_col_frame.pack(pady=5, fill="x")
        right2_col_frame.columnconfigure(1, weight=1)
        ttk.Label(right2_col_frame, text="Right Y-axis 2 Columns:").grid(row=0, column=0, sticky="nw")
        self.right2_y_listbox = tk.Listbox(right2_col_frame, selectmode="multiple", height=5, exportselection=False)
        self.right2_y_listbox.grid(row=0, column=1, padx=(5,2), pady=2, sticky="nsew")
        self.right2_y_listbox_scroll = ttk.Scrollbar(right2_col_frame, orient="vertical", command=self.right2_y_listbox.yview)
        self.right2_y_listbox_scroll.grid(row=0, column=2, sticky="ns", padx=(0,4), pady=2)
        self.right2_y_listbox.configure(yscrollcommand=self.right2_y_listbox_scroll.set)
        self.right2_y_listbox.bind("<<ListboxSelect>>", lambda e: self.update_right2_line_properties())

        # Move Up / Move Down for right2 selection
        move_up_btn_r2 = ttk.Button(right2_col_frame, text="Move Up", command=lambda: self.move_selected_in_listbox(self.right2_y_listbox, direction=-1))
        move_up_btn_r2.grid(row=1, column=1, sticky="w", padx=4, pady=(4,2))
        move_down_btn_r2 = ttk.Button(right2_col_frame, text="Move Down", command=lambda: self.move_selected_in_listbox(self.right2_y_listbox, direction=1))
        move_down_btn_r2.grid(row=1, column=1, sticky="e", padx=4, pady=(4,2))

        ttk.Button(right2_col_frame, text="Reset Right Y-axis 2 Section", command=self.reset_right2_axis).grid(row=2, column=1, sticky="e", pady=2, padx=4)

        # Move Right2 position control into this selection section (per user request)
        ttk.Label(right2_col_frame, text="Right2 Position (axes coord):").grid(row=3, column=0, sticky="w", pady=(6,0))
        right2_pos_spin = ttk.Spinbox(right2_col_frame, from_=1.0, to=3.0, increment=0.1, textvariable=self.right2_pos, width=8, command=self.schedule_preview)
        right2_pos_spin.grid(row=3, column=1, sticky="w", padx=(4,2), pady=(6,0))
        right2_pos_spin.bind("<KeyRelease>", lambda e: self.schedule_preview())

        # --- Line Properties Section (Right Y-axis 2) (left column) ---
        self.right2_line_prop_frame = ttk.LabelFrame(self.main_frame, text="Per-Channel Label + Properties (Right Y-axis 2)")
        self.right2_line_prop_frame.pack(pady=5, fill="both")
        ttk.Button(self.right2_line_prop_frame, text="Reset Right2 Line Properties", command=self.reset_right2_line_properties).pack(anchor="e", padx=4, pady=2)

        # --- Labels, Legend & other Global Settings Section (left column) ---
        label_frame = ttk.LabelFrame(self.main_frame, text="Labels, Legend & other Global Settings")
        label_frame.pack(pady=5, fill="x")
        for i in range(10):
            label_frame.columnconfigure(i, weight=1 if i in (1,3,5,7,9) else 0)

        ttk.Label(label_frame, text="Title:").grid(row=0, column=0, sticky="w")
        self.title_entry = ttk.Entry(label_frame, width=20)
        self.title_entry.grid(row=0, column=1, sticky="ew", padx=2)
        self.title_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())

        ttk.Label(label_frame, text="X-label:").grid(row=0, column=2, sticky="w")
        self.xlabel_entry = ttk.Entry(label_frame, width=15)
        self.xlabel_entry.grid(row=0, column=3, sticky="ew", padx=2)
        self.xlabel_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())

        ttk.Label(label_frame, text="Left Y-label:").grid(row=0, column=4, sticky="w")
        self.ylabel_entry = ttk.Entry(label_frame, width=15)
        self.ylabel_entry.grid(row=0, column=5, sticky="ew", padx=2)
        self.ylabel_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())

        ttk.Label(label_frame, text="Right Y-label:").grid(row=0, column=6, sticky="w")
        self.right_ylabel_entry = ttk.Entry(label_frame, width=15)
        self.right_ylabel_entry.grid(row=0, column=7, sticky="ew", padx=2)
        self.right_ylabel_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())

        # Additional right2 ylabel
        ttk.Label(label_frame, text="Right2 Y-label:").grid(row=0, column=8, sticky="w")
        self.right2_ylabel_entry = ttk.Entry(label_frame, width=15)
        self.right2_ylabel_entry.grid(row=0, column=9, sticky="ew", padx=2)
        self.right2_ylabel_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())

        ttk.Label(label_frame, text="Left Legend Pos:").grid(row=1, column=0, sticky="w")
        self.legend_loc_left = ttk.Combobox(label_frame, values=[
            "best","upper right","upper left","lower right","lower left","center",
            "outside top","outside bottom","outside left","outside right"], state="readonly")
        self.legend_loc_left.current(0)
        self.legend_loc_left.grid(row=1, column=1, sticky="ew", padx=2)
        self.legend_loc_left.bind("<<ComboboxSelected>>", lambda e: self.schedule_preview())

        ttk.Label(label_frame, text="Right Legend Pos:").grid(row=1, column=2, sticky="w")
        self.legend_loc_right = ttk.Combobox(label_frame, values=[
            "best","upper right","upper left","lower right","lower left","center",
            "outside top","outside bottom","outside left","outside right"], state="readonly")
        self.legend_loc_right.current(0)
        self.legend_loc_right.grid(row=1, column=3, sticky="ew", padx=2)
        self.legend_loc_right.bind("<<ComboboxSelected>>", lambda e: self.schedule_preview())

        ttk.Label(label_frame, text="Right2 Legend Pos:").grid(row=1, column=4, sticky="w")
        self.legend_loc_right2 = ttk.Combobox(label_frame, values=[
            "best","upper right","upper left","lower right","lower left","center",
            "outside top","outside bottom","outside left","outside right"], state="readonly")
        self.legend_loc_right2.current(0)
        self.legend_loc_right2.grid(row=1, column=5, sticky="ew", padx=2)
        self.legend_loc_right2.bind("<<ComboboxSelected>>", lambda e: self.schedule_preview())

        # Legend columns
        ttk.Label(label_frame, text="Left Legend Columns:").grid(row=2, column=0, sticky="w")
        self.legend_cols_left = tk.IntVar(value=1)
        ttk.Spinbox(label_frame, from_=1, to=10, textvariable=self.legend_cols_left, width=5, command=self.schedule_preview).grid(row=2, column=1, sticky="w", padx=2)
        ttk.Label(label_frame, text="Right Legend Columns:").grid(row=2, column=2, sticky="w")
        self.legend_cols_right = tk.IntVar(value=1)
        ttk.Spinbox(label_frame, from_=1, to=10, textvariable=self.legend_cols_right, width=5, command=self.schedule_preview).grid(row=2, column=3, sticky="w", padx=2)
        ttk.Label(label_frame, text="Right2 Legend Columns:").grid(row=2, column=4, sticky="w")
        self.legend_cols_right2 = tk.IntVar(value=1)
        ttk.Spinbox(label_frame, from_=1, to=10, textvariable=self.legend_cols_right2, width=5, command=self.schedule_preview).grid(row=2, column=5, sticky="w", padx=2)

        # Custom legend positions (left/right/right2)
        ttk.Label(label_frame, text="Left Legend X:").grid(row=3, column=0, sticky="w")
        self.legend_x_left = tk.StringVar(value="")
        ttk.Entry(label_frame, textvariable=self.legend_x_left, width=8).grid(row=3, column=1, sticky="w", padx=2)
        self.legend_x_left.trace_add("write", lambda *a: self.schedule_preview())
        ttk.Label(label_frame, text="Left Legend Y:").grid(row=3, column=2, sticky="w")
        self.legend_y_left = tk.StringVar(value="")
        ttk.Entry(label_frame, textvariable=self.legend_y_left, width=8).grid(row=3, column=3, sticky="w", padx=2)
        self.legend_y_left.trace_add("write", lambda *a: self.schedule_preview())

        ttk.Label(label_frame, text="Right Legend X:").grid(row=3, column=4, sticky="w")
        self.legend_x_right = tk.StringVar(value="")
        ttk.Entry(label_frame, textvariable=self.legend_x_right, width=8).grid(row=3, column=5, sticky="w", padx=2)
        self.legend_x_right.trace_add("write", lambda *a: self.schedule_preview())
        ttk.Label(label_frame, text="Right Legend Y:").grid(row=3, column=6, sticky="w")
        self.legend_y_right = tk.StringVar(value="")
        ttk.Entry(label_frame, textvariable=self.legend_y_right, width=8).grid(row=3, column=7, sticky="w", padx=2)
        self.legend_y_right.trace_add("write", lambda *a: self.schedule_preview())

        ttk.Label(label_frame, text="Right2 Legend X:").grid(row=4, column=0, sticky="w")
        self.legend_x_right2 = tk.StringVar(value="")
        ttk.Entry(label_frame, textvariable=self.legend_x_right2, width=8).grid(row=4, column=1, sticky="w", padx=2)
        self.legend_x_right2.trace_add("write", lambda *a: self.schedule_preview())
        ttk.Label(label_frame, text="Right2 Legend Y:").grid(row=4, column=2, sticky="w")
        self.legend_y_right2 = tk.StringVar(value="")
        ttk.Entry(label_frame, textvariable=self.legend_y_right2, width=8).grid(row=4, column=3, sticky="w", padx=2)
        self.legend_y_right2.trace_add("write", lambda *a: self.schedule_preview())

        # Global marker size control
        ttk.Label(label_frame, text="Global Marker Size:").grid(row=2, column=6, sticky="w")
        marker_spin = ttk.Spinbox(label_frame, from_=0.1, to=50.0, increment=0.5, textvariable=self.marker_size, width=6, command=self.schedule_preview)
        marker_spin.grid(row=2, column=7, sticky="w", padx=2)
        marker_spin.bind("<KeyRelease>", lambda e: self.schedule_preview())

        # Global line width (replaces per-channel Width)
        ttk.Label(label_frame, text="Global Line Width:").grid(row=3, column=6, sticky="w")
        global_width_spin = ttk.Spinbox(label_frame, from_=0.1, to=20.0, increment=0.1, textvariable=self.global_line_width, width=6, command=self.schedule_preview)
        global_width_spin.grid(row=3, column=7, sticky="w", padx=2)
        global_width_spin.bind("<KeyRelease>", lambda e: self.schedule_preview())

        ttk.Label(label_frame, text="Global Font Size:").grid(row=1, column=6, sticky="w")
        self.font_size = tk.IntVar(value=12)
        ttk.Spinbox(label_frame, from_=8, to=24, textvariable=self.font_size, command=self.schedule_preview).grid(row=1, column=7, sticky="w", padx=2)
        self.grid_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(label_frame, text="Show Grid", variable=self.grid_var, command=self.schedule_preview).grid(row=1, column=8, sticky="w", padx=2)
        ttk.Button(label_frame, text="Reset Labels Section", command=self.reset_labels).grid(row=1, column=9, sticky="e", padx=2)

        # --- Axis Colors (spine/labels/ticks) ---
        axis_ctrl_frame = ttk.LabelFrame(self.main_frame, text="Axis Colors")
        axis_ctrl_frame.pack(pady=5, fill="x")

        # Left axis color controls
        ttk.Label(axis_ctrl_frame, text="Left Axis Color:").grid(row=0, column=0, sticky="w")
        self.left_axis_swatch = tk.Label(axis_ctrl_frame, background=self.left_axis_color.get(), width=2, relief="sunken")
        self.left_axis_swatch.grid(row=0, column=1, sticky="w", padx=(4,2))
        ttk.Button(axis_ctrl_frame, text="Choose", command=lambda: self.choose_axis_color('left', self.left_axis_swatch)).grid(row=0, column=2, padx=4)

        # Right axis color controls
        ttk.Label(axis_ctrl_frame, text="Right Axis Color:").grid(row=1, column=0, sticky="w")
        self.right_axis_swatch = tk.Label(axis_ctrl_frame, background=self.right_axis_color.get(), width=2, relief="sunken")
        self.right_axis_swatch.grid(row=1, column=1, sticky="w", padx=(4,2))
        ttk.Button(axis_ctrl_frame, text="Choose", command=lambda: self.choose_axis_color('right', self.right_axis_swatch)).grid(row=1, column=2, padx=4)

        # Right2 axis color controls
        ttk.Label(axis_ctrl_frame, text="Right2 Axis Color:").grid(row=2, column=0, sticky="w")
        self.right2_axis_swatch = tk.Label(axis_ctrl_frame, background=self.right2_axis_color.get(), width=2, relief="sunken")
        self.right2_axis_swatch.grid(row=2, column=1, sticky="w", padx=(4,2))
        ttk.Button(axis_ctrl_frame, text="Choose", command=lambda: self.choose_axis_color('right2', self.right2_axis_swatch)).grid(row=2, column=2, padx=4)

        # Reset Axis Colors button
        ttk.Button(axis_ctrl_frame, text="Reset Axis Colors", command=self.reset_axis_colors).grid(row=0, column=3, rowspan=2, padx=8, sticky="e")

        # --- Axis Limits Section (left column) ---
        limit_frame = ttk.LabelFrame(self.main_frame, text="Axis Limits (optional)")
        limit_frame.pack(pady=5, fill="x")
        # make room for extra right2 min/max columns
        for i in range(18):
            limit_frame.columnconfigure(i, weight=1 if i % 2 == 1 else 0)

        ttk.Label(limit_frame, text="X-min:").grid(row=0, column=0)
        self.xmin_entry = ttk.Entry(limit_frame, width=8)
        self.xmin_entry.grid(row=0, column=1)
        self.xmin_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())
        ttk.Label(limit_frame, text="X-max:").grid(row=0, column=2)
        self.xmax_entry = ttk.Entry(limit_frame, width=8)
        self.xmax_entry.grid(row=0, column=3)
        self.xmax_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())
        ttk.Label(limit_frame, text="Left Y-min:").grid(row=0, column=4)
        self.ymin_entry = ttk.Entry(limit_frame, width=8)
        self.ymin_entry.grid(row=0, column=5)
        self.ymin_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())
        ttk.Label(limit_frame, text="Left Y-max:").grid(row=0, column=6)
        self.ymax_entry = ttk.Entry(limit_frame, width=8)
        self.ymax_entry.grid(row=0, column=7)
        self.ymax_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())
        ttk.Label(limit_frame, text="Right Y-min:").grid(row=0, column=8)
        self.right_ymin_entry = ttk.Entry(limit_frame, width=8)
        self.right_ymin_entry.grid(row=0, column=9)
        self.right_ymin_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())
        ttk.Label(limit_frame, text="Right Y-max:").grid(row=0, column=10)
        self.right_ymax_entry = ttk.Entry(limit_frame, width=8)
        self.right_ymax_entry.grid(row=0, column=11)
        self.right_ymax_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())

        # New Right2 axis limits
        ttk.Label(limit_frame, text="Right2 Y-min:").grid(row=0, column=12)
        self.right2_ymin_entry = ttk.Entry(limit_frame, width=8)
        self.right2_ymin_entry.grid(row=0, column=13)
        self.right2_ymin_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())
        ttk.Label(limit_frame, text="Right2 Y-max:").grid(row=0, column=14)
        self.right2_ymax_entry = ttk.Entry(limit_frame, width=8)
        self.right2_ymax_entry.grid(row=0, column=15)
        self.right2_ymax_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())

        # --- Interval inputs (difference between visible tickmarks) ---
        ttk.Label(limit_frame, text="X-interval:").grid(row=1, column=0)
        self.xinterval_entry = ttk.Entry(limit_frame, width=8)
        self.xinterval_entry.grid(row=1, column=1)
        self.xinterval_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())

        ttk.Label(limit_frame, text="Left Y-interval:").grid(row=1, column=2)
        self.yinterval_entry = ttk.Entry(limit_frame, width=8)
        self.yinterval_entry.grid(row=1, column=3)
        self.yinterval_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())

        ttk.Label(limit_frame, text="Right Y-interval:").grid(row=1, column=4)
        self.right_yinterval_entry = ttk.Entry(limit_frame, width=8)
        self.right_yinterval_entry.grid(row=1, column=5)
        self.right_yinterval_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())

        ttk.Label(limit_frame, text="Right2 Y-interval:").grid(row=1, column=6)
        self.right2_yinterval_entry = ttk.Entry(limit_frame, width=8)
        self.right2_yinterval_entry.grid(row=1, column=7)
        self.right2_yinterval_entry.bind("<KeyRelease>", lambda e: self.schedule_preview())
        # --- end interval inputs ---

        ttk.Button(limit_frame, text="Reset Axis Limits Section", command=self.reset_limits).grid(row=0, column=16, padx=5)

        # --- Plot Preview Section (right column) ---
        preview_frame = ttk.LabelFrame(self.preview_parent, text="Plot Preview")
        preview_frame.pack(pady=5, fill="both", expand=True)

        self.preview_canvas_container = tk.Frame(preview_frame)
        self.preview_canvas_container.pack(fill="both", expand=True)

        # create an initial figure large enough for 12x8 inches
        self.fig = plt.Figure(figsize=(self.default_plot_width, self.default_plot_height))
        self.ax = self.fig.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.preview_canvas_container)
        self.canvas_widget = self.canvas.get_tk_widget()
        # Allow the canvas widget to expand fully to hold large figure
        self.canvas_widget.pack(side="left", fill="both", expand=True)

        # Controls for preview behavior (live toggle + Preview + Cancel + downsampling)
        controls_frame = ttk.Frame(preview_frame)
        controls_frame.pack(anchor="w", pady=2, fill="x")

        # Live preview checkbox
        live_chk = ttk.Checkbutton(controls_frame, text="Enable Live Preview", variable=self.live_preview_var, command=self._on_live_toggle)
        live_chk.grid(row=0, column=0, padx=(2,8), sticky="w")

        # Downsample live preview toggle and max points control
        downsample_chk = ttk.Checkbutton(controls_frame, text="Downsample Live Preview", variable=self.downsample_live_var, command=self.schedule_preview)
        downsample_chk.grid(row=0, column=1, padx=(2,8), sticky="w")
        ttk.Label(controls_frame, text="Max pts/series:").grid(row=0, column=2, padx=(2,2))
        self.max_pts_spin = ttk.Spinbox(controls_frame, from_=100, to=1000000, increment=100, textvariable=self.max_preview_points, width=8, command=self.schedule_preview)
        self.max_pts_spin.grid(row=0, column=3, padx=(2,8))
        self.max_pts_spin.bind("<KeyRelease>", lambda e: self.schedule_preview())

        # Preview button (explicit)
        preview_btn = ttk.Button(controls_frame, text="Preview Plot", command=lambda: self._explicit_preview())
        preview_btn.grid(row=0, column=4, padx=(2,8))

        # Cancel button to cancel scheduled preview and request cancellation of ongoing preview
        cancel_btn = ttk.Button(controls_frame, text="Cancel Preview", command=self.cancel_preview)
        cancel_btn.grid(row=0, column=5, padx=(2,8))

        # Plot size controls default to 12x8 (right column)
        size_frame = ttk.Frame(preview_frame)
        size_frame.pack(anchor="w", pady=2, fill="x")
        ttk.Label(size_frame, text="Plot Width (inches):").grid(row=0, column=0)
        self.plot_width = tk.DoubleVar(value=self.default_plot_width)
        w_plot = ttk.Entry(size_frame, textvariable=self.plot_width, width=6)
        w_plot.grid(row=0, column=1)
        w_plot.bind("<KeyRelease>", lambda e: self.schedule_preview())

        ttk.Label(size_frame, text="Plot Height (inches):").grid(row=0, column=2)
        self.plot_height = tk.DoubleVar(value=self.default_plot_height)
        h_plot = ttk.Entry(size_frame, textvariable=self.plot_height, width=6)
        h_plot.grid(row=0, column=3)
        h_plot.bind("<KeyRelease>", lambda e: self.schedule_preview())

        ttk.Button(size_frame, text="Preview Plot", command=self.preview_plot).grid(row=0, column=4, padx=6)

        # --- Configuration Section (new) ---
        config_frame = ttk.LabelFrame(self.preview_parent, text="Configuration")
        config_frame.pack(pady=5, fill="x")
        ttk.Button(config_frame, text="Save Configuration", command=self.save_configuration).pack(side="left", padx=4)
        ttk.Button(config_frame, text="Load Configuration", command=self.load_configuration).pack(side="left", padx=4)
        ttk.Button(config_frame, text="Reset All", command=self.reset_all).pack(side="right", padx=4)

        # --- Save Section (right column) ---
        save_frame = ttk.LabelFrame(self.preview_parent, text="Save Plot")
        save_frame.pack(pady=5, fill="x")
        ttk.Label(save_frame, text="Select PNG Quality (DPI):").pack(side="left")
        self.dpi_option = ttk.Combobox(save_frame, values=[100,150,200,300,600], state="readonly")
        self.dpi_option.current(2)
        self.dpi_option.pack(side="left", padx=5)
        ttk.Button(save_frame, text="Save PNG", command=self.save_png).pack(side="left", padx=5)

        # Initial bindings left/right lists to ensure preview schedule when selection changes
        self.x_combo.bind("<<ComboboxSelected>>", lambda e: self.schedule_preview())
        self.y_listbox.bind("<<ListboxSelect>>", lambda e: self.update_line_properties())
        self.right_y_listbox.bind("<<ListboxSelect>>", lambda e: self.update_right_line_properties())
        self.right2_y_listbox.bind("<<ListboxSelect>>", lambda e: self.update_right2_line_properties())

    # ---------------- Helpers & PEC loader ----------------
    def choose_axis_color(self, axis, swatch_label):
        color_code = colorchooser.askcolor(title="Choose Axis Color")[1]
        if not color_code:
            return
        if axis == 'left':
            self.left_axis_color.set(color_code)
        elif axis == 'right':
            self.right_axis_color.set(color_code)
        elif axis == 'right2':
            self.right2_axis_color.set(color_code)
        try:
            swatch_label.configure(background=color_code)
        except Exception:
            pass
        self.schedule_preview()

    def reset_axis_colors(self):
        self.left_axis_color.set("#000000")
        self.right_axis_color.set("#1f77b4")
        self.right2_axis_color.set("#d62728")
        try:
            self.left_axis_swatch.configure(background=self.left_axis_color.get())
            self.right_axis_swatch.configure(background=self.right_axis_color.get())
            self.right2_axis_swatch.configure(background=self.right2_axis_color.get())
        except Exception:
            pass
        self.schedule_preview()

    def choose_marker_color(self, row_frame, swatch_label):
        color_code = colorchooser.askcolor(title="Choose Marker Color")[1]
        if color_code:
            row_frame.marker_color = color_code
            try:
                swatch_label.configure(background=color_code)
            except Exception:
                pass
            # sync immediately so moves preserve this choice
            self.sync_channel_props_from_frames()
            self.schedule_preview()

    def choose_color(self, frame_row, swatch_label):
        """Open a color chooser and update the row's stored color and swatch (line color)."""
        color_code = colorchooser.askcolor(title="Choose Line Color")[1]
        if color_code:
            frame_row.line_color = color_code
            try:
                swatch_label.configure(background=color_code)
            except Exception:
                pass
            self.sync_channel_props_from_frames()
            self.schedule_preview()

    # ---------------- Added missing method: select_all_left ----------------
    def select_all_left(self):
        """Select all entries in the left Y-axis listbox and update property rows."""
        try:
            self.y_listbox.selection_set(0, tk.END)
            # ensure the visual selection shows
            self.y_listbox.see(0)
            self.update_line_properties()
        except Exception:
            pass

    # ---------------- PEC cycler fallback loader ----------------
    def load_csv_with_dynamic_header(self, file_path, min_consistent_lines=3, min_cols=5):
        """
        Attempt to parse a PEC cycler CSV that has metadata lines before the data table.
        Heuristic:
          - Read all lines.
          - For each line i, split by comma; if number of columns >= min_cols and
            next (min_consistent_lines-1) non-empty lines have same number of columns,
            treat line i as header.
        Returns DataFrame and sets self.detected_header_line_index.
        """
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            lines = f.read().splitlines()

        # Remove completely empty lines at top (if any)
        while lines and lines[0].strip() == "":
            lines.pop(0)

        candidate_idx = None
        for i in range(len(lines)):
            parts = lines[i].split(',')
            col_count = len(parts)
            if col_count < min_cols:
                continue
            consistent = True
            for k in range(1, min_consistent_lines):
                j = i + k
                if j >= len(lines):
                    consistent = False
                    break
                parts_next = lines[j].split(',')
                if len(parts_next) != col_count:
                    consistent = False
                    break
            if consistent:
                candidate_idx = i
                break

        if candidate_idx is None:
            raise ValueError("Could not auto-detect data header line in PEC-style CSV.")

        # Rebuild CSV from candidate_idx onward
        reconstructed = "\n".join(lines[candidate_idx:])
        sio = io.StringIO(reconstructed)
        df = pd.read_csv(sio)
        # store detected header line index (relative to file's original first line)
        self.detected_header_line_index = candidate_idx
        return df

    def browse_file(self):
        file_path = filedialog.askopenfilename(filetypes=[("CSV files","*.csv"), ("All files","*.*")])
        if file_path:
            self.file_entry.delete(0, "end")
            self.file_entry.insert(0, file_path)
            self.load_csv(file_path)

    def load_csv(self, file_path):
        """
        Original loader; on failure due to tokenizing inconsistent rows, attempt PEC fallback.
        """
        # reset detected header index for new file
        self.detected_header_line_index = None
        try:
            self.df = pd.read_csv(file_path)
        except Exception as e:
            # Attempt fallback only for tokenizing / parsing errors
            if "Error tokenizing data" in str(e) or "expected" in str(e):
                try:
                    self.df = self.load_csv_with_dynamic_header(file_path)
                    messagebox.showinfo("PEC CSV Loaded", f"Loaded PEC-style CSV starting from detected header line {self.detected_header_line_index}.\nFile: {os.path.basename(file_path)}")
                except Exception as e2:
                    messagebox.showerror("Error", f"Failed to parse CSV:\n{e}\nFallback parsing also failed:\n{e2}")
                    return
            else:
                messagebox.showerror("Error", str(e))
                return

        # Populate UI with columns
        self.x_combo["values"] = list(self.df.columns)
        self.y_listbox.delete(0, "end")
        self.right_y_listbox.delete(0, "end")
        self.right2_y_listbox.delete(0, "end")
        for col in self.df.columns:
            self.y_listbox.insert("end", col)
            self.right_y_listbox.insert("end", col)
            self.right2_y_listbox.insert("end", col)
        # Clear frames and rebuild when selection occurs
        self.reset_line_properties()
        self.reset_right_line_properties()
        self.reset_right2_line_properties()
        self.schedule_preview()

    # ---------------- Channel props sync helpers ----------------
    def sync_channel_props_from_frames(self):
        """
        Scan existing frames for left/right/right2 and update the persistent dicts keyed by original column name.
        This is called before moves/rebuilds to preserve current customizations.
        """
        try:
            # left
            for row in self.line_properties_frames:
                col = getattr(row, "_col_name", None)
                if not col:
                    continue
                try:
                    self.left_channel_props[col] = {
                        "label": row._linked_label_var.get() if hasattr(row, "_linked_label_var") else col,
                        "line_color": getattr(row, "line_color", ""),
                        "marker_color": getattr(row, "marker_color", "") or "",
                        "style": row.line_style.get() if hasattr(row, "line_style") else "",
                        "marker": row.marker.get() if hasattr(row, "marker") else ""
                    }
                except Exception:
                    continue
            # right
            for row in self.right_line_properties_frames:
                col = getattr(row, "_col_name", None)
                if not col:
                    continue
                try:
                    self.right_channel_props[col] = {
                        "label": row._linked_label_var.get() if hasattr(row, "_linked_label_var") else col,
                        "line_color": getattr(row, "line_color", ""),
                        "marker_color": getattr(row, "marker_color", "") or "",
                        "style": row.line_style.get() if hasattr(row, "line_style") else "",
                        "marker": row.marker.get() if hasattr(row, "marker") else ""
                    }
                except Exception:
                    continue
            # right2
            for row in self.right2_line_properties_frames:
                col = getattr(row, "_col_name", None)
                if not col:
                    continue
                try:
                    self.right2_channel_props[col] = {
                        "label": row._linked_label_var.get() if hasattr(row, "_linked_label_var") else col,
                        "line_color": getattr(row, "line_color", ""),
                        "marker_color": getattr(row, "marker_color", "") or "",
                        "style": row.line_style.get() if hasattr(row, "line_style") else "",
                        "marker": row.marker.get() if hasattr(row, "marker") else ""
                    }
                except Exception:
                    continue
        except Exception:
            pass

    def apply_props_to_row(self, row, col, props_map):
        """
        Apply saved props from props_map (dict keyed by column) to a newly created row widget.
        """
        try:
            row._col_name = col
            p = props_map.get(col, {})
            # label
            if 'label' in p and hasattr(row, "_linked_label_var"):
                try: row._linked_label_var.set(p.get('label', row._linked_label_var.get()))
                except Exception: pass
            # line color
            if 'line_color' in p and p.get('line_color'):
                try:
                    row.line_color = p.get('line_color')
                    if hasattr(row, "_swatch") and row._swatch:
                        row._swatch.configure(background=row.line_color)
                except Exception:
                    pass
            # marker color
            mc = p.get('marker_color', "")
            if mc:
                try:
                    row.marker_color = mc
                    if hasattr(row, "_marker_swatch") and row._marker_swatch:
                        row._marker_swatch.configure(background=mc)
                except Exception:
                    pass
            # style
            if 'style' in p and hasattr(row, 'line_style'):
                try: row.line_style.set(p.get('style', row.line_style.get()))
                except Exception: pass
            # marker
            if 'marker' in p and hasattr(row, 'marker'):
                try: row.marker.set(p.get('marker', row.marker.get()))
                except Exception: pass
        except Exception:
            pass

    # ---------------- Move selected items with preservation ----------------
    def move_selected_in_listbox(self, listbox, direction=1):
        """
        Move selected items in the given listbox up (direction=-1) or down (direction=1).
        Preserve per-row customizations by syncing current frames into props maps,
        then performing swaps on the listbox entries. After moving, rebuild the
        property rows (they'll re-apply saved props from the maps).
        """
        try:
            # sync current frames into maps
            self.sync_channel_props_from_frames()

            items = list(listbox.get(0, tk.END))
            sel = list(listbox.curselection())
            if not sel:
                return
            n = len(items)

            # perform swaps on items list
            if direction < 0:
                # move up: process indices in ascending order
                for idx in sel:
                    if idx == 0:
                        continue
                    items[idx-1], items[idx] = items[idx], items[idx-1]
                new_sel = [max(0, i-1) for i in sel]
            else:
                # move down: process in descending order
                for idx in reversed(sel):
                    if idx >= n-1:
                        continue
                    items[idx+1], items[idx] = items[idx], items[idx+1]
                new_sel = [min(n-1, i+1) for i in sel]

            # repopulate listbox
            listbox.delete(0, tk.END)
            for it in items:
                listbox.insert(tk.END, it)

            # restore selection
            listbox.selection_clear(0, tk.END)
            for i in new_sel:
                listbox.selection_set(i)

            # rebuild property rows to reflect new order and reapply props from maps
            if listbox is self.y_listbox:
                self.update_line_properties()
            elif listbox is self.right_y_listbox:
                self.update_right_line_properties()
            elif listbox is self.right2_y_listbox:
                self.update_right2_line_properties()
        except Exception:
            pass

    # ---------------- PEC CSV + file handling (unchanged aside from header index store) ----------------
    def load_csv_with_dynamic_header(self, file_path, min_consistent_lines=3, min_cols=5):
        """
        Attempt to parse a PEC cycler CSV that has metadata lines before the data table.
        Heuristic:
          - Read all lines.
          - For each line i, split by comma; if number of columns >= min_cols and
            next (min_consistent_lines-1) non-empty lines have same number of columns,
            treat line i as header.
        Returns DataFrame and sets self.detected_header_line_index.
        """
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            lines = f.read().splitlines()

        # Remove completely empty lines at top (if any)
        while lines and lines[0].strip() == "":
            lines.pop(0)

        candidate_idx = None
        for i in range(len(lines)):
            parts = lines[i].split(',')
            col_count = len(parts)
            if col_count < min_cols:
                continue
            consistent = True
            for k in range(1, min_consistent_lines):
                j = i + k
                if j >= len(lines):
                    consistent = False
                    break
                parts_next = lines[j].split(',')
                if len(parts_next) != col_count:
                    consistent = False
                    break
            if consistent:
                candidate_idx = i
                break

        if candidate_idx is None:
            raise ValueError("Could not auto-detect data header line in PEC-style CSV.")

        # Rebuild CSV from candidate_idx onward
        reconstructed = "\n".join(lines[candidate_idx:])
        sio = io.StringIO(reconstructed)
        df = pd.read_csv(sio)
        # store detected header line index (relative to file's original first line)
        self.detected_header_line_index = candidate_idx
        return df

    def browse_file(self):
        file_path = filedialog.askopenfilename(filetypes=[("CSV files","*.csv"), ("All files","*.*")])
        if file_path:
            self.file_entry.delete(0, "end")
            self.file_entry.insert(0, file_path)
            self.load_csv(file_path)

    def load_csv(self, file_path):
        """
        Original loader; on failure due to tokenizing inconsistent rows, attempt PEC fallback.
        """
        # reset detected header index for new file
        self.detected_header_line_index = None
        try:
            self.df = pd.read_csv(file_path)
        except Exception as e:
            # Attempt fallback only for tokenizing / parsing errors
            if "Error tokenizing data" in str(e) or "expected" in str(e):
                try:
                    self.df = self.load_csv_with_dynamic_header(file_path)
                    messagebox.showinfo("PEC CSV Loaded", f"Loaded PEC-style CSV starting from detected header line {self.detected_header_line_index}.\nFile: {os.path.basename(file_path)}")
                except Exception as e2:
                    messagebox.showerror("Error", f"Failed to parse CSV:\n{e}\nFallback parsing also failed:\n{e2}")
                    return
            else:
                messagebox.showerror("Error", str(e))
                return

        # Populate UI with columns
        self.x_combo["values"] = list(self.df.columns)
        self.y_listbox.delete(0, "end")
        self.right_y_listbox.delete(0, "end")
        self.right2_y_listbox.delete(0, "end")
        for col in self.df.columns:
            self.y_listbox.insert("end", col)
            self.right_y_listbox.insert("end", col)
            self.right2_y_listbox.insert("end", col)
        # Clear frames and rebuild when selection occurs
        self.reset_line_properties()
        self.reset_right_line_properties()
        self.reset_right2_line_properties()
        self.schedule_preview()

    # ---------------- Reset / UI helpers (unchanged aside from syncing) ----------------
    def reset_all(self):
        """
        Reset everything in the GUI to defaults.
        This clears the loaded CSV, all selections, and restores default settings.
        """
        try:
            # Clear CSV and selections
            self.df = None
            self.file_entry.delete(0, "end")
            self.x_combo.set("")
            self.x_combo["values"] = []
            # clear listboxes
            self.y_listbox.delete(0, tk.END)
            self.right_y_listbox.delete(0, tk.END)
            self.right2_y_listbox.delete(0, tk.END)
            # reset per-channel property frames
            self.reset_line_properties()
            self.reset_right_line_properties()
            self.reset_right2_line_properties()
            # also clear persistent props maps
            self.left_channel_props.clear()
            self.right_channel_props.clear()
            self.right2_channel_props.clear()
            self.detected_header_line_index = None
            # reset labels, global settings, axis colors, limits
            self.reset_labels()
            self.reset_limits()
            self.reset_axis_colors()
            # preview/downsampling defaults
            self.live_preview_var.set(True)
            self.downsample_live_var.set(True)
            self.max_preview_points.set(5000)
            # global line width & marker size defaults
            self.global_line_width.set(1.0)
            self.marker_size.set(6.0)
            # plot size defaults
            self.plot_width.set(self.default_plot_width)
            self.plot_height.set(self.default_plot_height)
            # dpi default
            try:
                self.dpi_option.current(2)
            except Exception:
                pass
            self.schedule_preview()
        except Exception:
            pass

    def _on_live_toggle(self):
        # If live preview was turned off while a preview was scheduled, cancel it.
        if not self.live_preview_var.get():
            if self._preview_after_id is not None:
                try:
                    self.root.after_cancel(self._preview_after_id)
                except Exception:
                    pass
                self._preview_after_id = None
        else:
            # If turned on, schedule an update (debounced)
            self.schedule_preview()

    def schedule_preview(self):
        """Debounced preview: cancel previous scheduled, schedule a new one.
        Respects the live preview toggle; if live preview is disabled, do nothing.
        """
        if not self.live_preview_var.get():
            return
        if self._preview_after_id is not None:
            try:
                self.root.after_cancel(self._preview_after_id)
            except Exception:
                pass
        self._preview_after_id = self.root.after(DEBOUNCE_MS, self.preview_plot)

    def cancel_preview(self):
        """Cancel scheduled preview and request cancellation of any ongoing preview."""
        # cancel any pending scheduled preview
        if self._preview_after_id is not None:
            try:
                self.root.after_cancel(self._preview_after_id)
            except Exception:
                pass
            self._preview_after_id = None
        # request cancellation of an ongoing preview
        self._preview_cancel_requested = True
        # also clear explicit flag
        self._explicit_preview_request = False

    def _explicit_preview(self):
        """User requested explicit preview (runs regardless of live-preview toggle)."""
        # Cancel any scheduled preview and run preview immediately
        if self._preview_after_id is not None:
            try:
                self.root.after_cancel(self._preview_after_id)
            except Exception:
                pass
            self._preview_after_id = None
        # Mark explicit request so preview_plot can bypass downsampling
        self._explicit_preview_request = True
        # Ensure cancel flag is cleared before starting
        self._preview_cancel_requested = False
        # Run preview immediately (use after(0) to avoid blocking current event handler stack)
        self.root.after(0, self.preview_plot)

    # ---------------- Reset Sections ----------------
    def reset_csv(self):
        self.file_entry.delete(0, "end")
        self.df = None
        self.x_combo.set("")
        self.y_listbox.delete(0, "end")
        self.right_y_listbox.delete(0, "end")
        self.right2_y_listbox.delete(0, "end")
        self.reset_line_properties()
        self.reset_right_line_properties()
        self.reset_right2_line_properties()
        self.schedule_preview()

    def reset_axis(self):
        self.x_combo.set("")
        self.y_listbox.selection_clear(0, "end")
        self.reset_line_properties()
        self.schedule_preview()

    def reset_right_axis(self):
        self.right_y_listbox.selection_clear(0, "end")
        self.reset_right_line_properties()
        self.schedule_preview()

    def reset_right2_axis(self):
        self.right2_y_listbox.selection_clear(0, "end")
        self.reset_right2_line_properties()
        self.schedule_preview()

    def reset_line_properties(self):
        for w in self.line_properties_frames:
            w.destroy()
        self.line_properties_frames.clear()
        self.schedule_preview()

    def reset_right_line_properties(self):
        for w in self.right_line_properties_frames:
            w.destroy()
        self.right_line_properties_frames.clear()
        self.schedule_preview()

    def reset_right2_line_properties(self):
        for w in self.right2_line_properties_frames:
            w.destroy()
        self.right2_line_properties_frames.clear()
        self.schedule_preview()

    def reset_labels(self):
        self.title_entry.delete(0, "end")
        self.xlabel_entry.delete(0, "end")
        self.ylabel_entry.delete(0, "end")
        self.right_ylabel_entry.delete(0, "end")
        self.right2_ylabel_entry.delete(0, "end")
        self.legend_loc_left.current(0)
        self.legend_loc_right.current(0)
        self.legend_loc_right2.current(0)
        self.legend_cols_left.set(1)
        self.legend_cols_right.set(1)
        self.legend_cols_right2.set(1)
        self.legend_x_left.set("")
        self.legend_y_left.set("")
        self.legend_x_right.set("")
        self.legend_y_right.set("")
        self.legend_x_right2.set("")
        self.legend_y_right2.set("")
        self.font_size.set(12)
        self.grid_var.set(True)
        self.marker_size.set(6.0)
        # reset axis colors to defaults
        self.left_axis_color.set("#000000")
        self.right_axis_color.set("#1f77b4")
        self.right2_axis_color.set("#d62728")
        self.right2_pos.set(1.2)
        # update swatches
        try:
            self.left_axis_swatch.configure(background=self.left_axis_color.get())
            self.right_axis_swatch.configure(background=self.right_axis_color.get())
            self.right2_axis_swatch.configure(background=self.right2_axis_color.get())
        except Exception:
            pass
        self.schedule_preview()

    def reset_limits(self):
        for entry in [self.xmin_entry, self.xmax_entry, self.ymin_entry, self.ymax_entry,
                      self.right_ymin_entry, self.right_ymax_entry, self.right2_ymin_entry, self.right2_ymax_entry,
                      self.xinterval_entry, self.yinterval_entry, self.right_yinterval_entry, self.right2_yinterval_entry]:
            try:
                entry.delete(0, "end")
            except Exception:
                pass
        self.schedule_preview()

    # ---------------- Update Line Properties (inline rows) with prop map application ----------------
    def update_line_properties(self):
        """
        Create inline rows in self.line_prop_frame for each selected left Y column.
        Uses left_channel_props map to restore saved per-column customizations.
        """
        # sync current frames into maps so user edits are preserved
        self.sync_channel_props_from_frames()

        self.reset_line_properties()
        selected_indices = self.y_listbox.curselection()
        y_cols = [self.y_listbox.get(i) for i in selected_indices]

        for col in y_cols:
            row = ttk.Frame(self.line_prop_frame)
            row.pack(fill="x", pady=1, padx=2)

            # store original column name on row for sync
            row._col_name = col

            # Column name
            ttk.Label(row, text=col, width=20).pack(side="left", padx=2)

            # Legend label entry (editable per-channel)
            label_var = tk.StringVar(value=col)
            label_entry = ttk.Entry(row, textvariable=label_var, width=30)
            label_entry.pack(side="left", padx=4)
            label_entry.bind("<KeyRelease>", lambda e: (self.sync_channel_props_from_frames(), self.schedule_preview()))

            # Line style
            style_var = tk.StringVar(value="-")
            ttk.Label(row, text="Style:").pack(side="left", padx=(8,2))
            style_cb = ttk.Combobox(row, values=["-","--","-.",":"], textvariable=style_var, width=4)
            style_cb.pack(side="left")
            style_cb.bind("<<ComboboxSelected>>", lambda e: (self.sync_channel_props_from_frames(), self.schedule_preview()))

            # Marker
            marker_var = tk.StringVar(value="None")
            ttk.Label(row, text="Marker:").pack(side="left", padx=(6,2))
            marker_cb = ttk.Combobox(row, values=["None","o","s","^","*"], textvariable=marker_var, width=4)
            marker_cb.pack(side="left")
            marker_cb.bind("<<ComboboxSelected>>", lambda e: (self.sync_channel_props_from_frames(), self.schedule_preview()))

            # Color swatch and choose button for line color
            color = next(self.color_cycle)
            swatch = tk.Label(row, background=color, width=2, relief="sunken")
            swatch.pack(side="left", padx=(6,2))
            color_btn = ttk.Button(row, text="Choose", command=lambda r=row, s=swatch: self.choose_color(r, s))
            color_btn.pack(side="left", padx=(2,6))

            # Marker color swatch and choose button (per-line)
            marker_color_swatch = tk.Label(row, background=color, width=2, relief="raised")
            marker_color_swatch.pack(side="left", padx=(4,2))
            row.marker_color = ""  # empty means fallback to line color
            row._marker_swatch = marker_color_swatch
            marker_color_btn = ttk.Button(row, text="Marker Color", command=lambda r=row, s=marker_color_swatch: self.choose_marker_color(r, s))
            marker_color_btn.pack(side="left", padx=(2,6))

            # Store properties into the row frame object
            row.line_color = color
            row.line_style = style_var
            row.marker = marker_var
            row._linked_label_var = label_var
            row._swatch = swatch

            # Apply any previously saved props for this column
            self.apply_props_to_row(row, col, self.left_channel_props)

            self.line_properties_frames.append(row)

        # schedule preview because structure (labels/properties) changed
        self.schedule_preview()

    def update_right_line_properties(self):
        self.sync_channel_props_from_frames()
        self.reset_right_line_properties()
        selected_indices = self.right_y_listbox.curselection()
        right_cols = [self.right_y_listbox.get(i) for i in selected_indices]

        for col in right_cols:
            row = ttk.Frame(self.right_line_prop_frame)
            row.pack(fill="x", pady=1, padx=2)

            row._col_name = col

            ttk.Label(row, text=col, width=20).pack(side="left", padx=2)

            label_var = tk.StringVar(value=col)
            label_entry = ttk.Entry(row, textvariable=label_var, width=30)
            label_entry.pack(side="left", padx=4)
            label_entry.bind("<KeyRelease>", lambda e: (self.sync_channel_props_from_frames(), self.schedule_preview()))

            style_var = tk.StringVar(value="-")
            ttk.Label(row, text="Style:").pack(side="left", padx=(8,2))
            style_cb = ttk.Combobox(row, values=["-","--","-.",":"], textvariable=style_var, width=4)
            style_cb.pack(side="left")
            style_cb.bind("<<ComboboxSelected>>", lambda e: (self.sync_channel_props_from_frames(), self.schedule_preview()))

            marker_var = tk.StringVar(value="None")
            ttk.Label(row, text="Marker:").pack(side="left", padx=(6,2))
            marker_cb = ttk.Combobox(row, values=["None","o","s","^","*"], textvariable=marker_var, width=4)
            marker_cb.pack(side="left")
            marker_cb.bind("<<ComboboxSelected>>", lambda e: (self.sync_channel_props_from_frames(), self.schedule_preview()))

            color = next(self.right_color_cycle)
            swatch = tk.Label(row, background=color, width=2, relief="sunken")
            swatch.pack(side="left", padx=(6,2))
            color_btn = ttk.Button(row, text="Choose", command=lambda r=row, s=swatch: self.choose_color(r, s))
            color_btn.pack(side="left", padx=(2,6))

            marker_color_swatch = tk.Label(row, background=color, width=2, relief="raised")
            marker_color_swatch.pack(side="left", padx=(4,2))
            row.marker_color = ""
            row._marker_swatch = marker_color_swatch
            marker_color_btn = ttk.Button(row, text="Marker Color", command=lambda r=row, s=marker_color_swatch: self.choose_marker_color(r, s))
            marker_color_btn.pack(side="left", padx=(2,6))

            row.line_color = color
            row.line_style = style_var
            row.marker = marker_var
            row._linked_label_var = label_var
            row._swatch = swatch

            self.apply_props_to_row(row, col, self.right_channel_props)

            self.right_line_properties_frames.append(row)

        self.schedule_preview()

    def update_right2_line_properties(self):
        self.sync_channel_props_from_frames()
        self.reset_right2_line_properties()
        selected_indices = self.right2_y_listbox.curselection()
        right2_cols = [self.right2_y_listbox.get(i) for i in selected_indices]

        for col in right2_cols:
            row = ttk.Frame(self.right2_line_prop_frame)
            row.pack(fill="x", pady=1, padx=2)

            row._col_name = col

            ttk.Label(row, text=col, width=20).pack(side="left", padx=2)

            label_var = tk.StringVar(value=col)
            label_entry = ttk.Entry(row, textvariable=label_var, width=30)
            label_entry.pack(side="left", padx=4)
            label_entry.bind("<KeyRelease>", lambda e: (self.sync_channel_props_from_frames(), self.schedule_preview()))

            style_var = tk.StringVar(value="-")
            ttk.Label(row, text="Style:").pack(side="left", padx=(8,2))
            style_cb = ttk.Combobox(row, values=["-","--","-.",":"], textvariable=style_var, width=4)
            style_cb.pack(side="left")
            style_cb.bind("<<ComboboxSelected>>", lambda e: (self.sync_channel_props_from_frames(), self.schedule_preview()))

            marker_var = tk.StringVar(value="None")
            ttk.Label(row, text="Marker:").pack(side="left", padx=(6,2))
            marker_cb = ttk.Combobox(row, values=["None","o","s","^","*"], textvariable=marker_var, width=4)
            marker_cb.pack(side="left")
            marker_cb.bind("<<ComboboxSelected>>", lambda e: (self.sync_channel_props_from_frames(), self.schedule_preview()))

            color = next(self.right2_color_cycle)
            swatch = tk.Label(row, background=color, width=2, relief="sunken")
            swatch.pack(side="left", padx=(6,2))
            color_btn = ttk.Button(row, text="Choose", command=lambda r=row, s=swatch: self.choose_color(r, s))
            color_btn.pack(side="left", padx=(2,6))

            marker_color_swatch = tk.Label(row, background=color, width=2, relief="raised")
            marker_color_swatch.pack(side="left", padx=(4,2))
            row.marker_color = ""
            row._marker_swatch = marker_color_swatch
            marker_color_btn = ttk.Button(row, text="Marker Color", command=lambda r=row, s=marker_color_swatch: self.choose_marker_color(r, s))
            marker_color_btn.pack(side="left", padx=(2,6))

            row.line_color = color
            row.line_style = style_var
            row.marker = marker_var
            row._linked_label_var = label_var
            row._swatch = swatch

            self.apply_props_to_row(row, col, self.right2_channel_props)

            self.right2_line_properties_frames.append(row)

        self.schedule_preview()

    # ---------------- Preview (unchanged from prior interval-enabled version) ----------------
    def preview_plot(self):
        # Clear scheduled id
        self._preview_after_id = None

        # Capture and clear explicit flag: we capture its value and then reset so subsequent scheduled previews are not explicit
        explicit = getattr(self, "_explicit_preview_request", False)
        self._explicit_preview_request = False

        # If there is no data, clear the figure and return
        if self.df is None:
            try:
                self.fig.clf()
                self.canvas.draw()
            except Exception:
                pass
            return

        # If user requested cancellation before start, abort
        if self._preview_cancel_requested:
            self._preview_cancel_requested = False
            return

        x_col = self.x_combo.get()
        selected_indices = self.y_listbox.curselection()
        right_indices = self.right_y_listbox.curselection()
        right2_indices = self.right2_y_listbox.curselection()
        if not x_col or (not selected_indices and not right_indices and not right2_indices):
            try:
                self.fig.clf()
                self.canvas.draw()
            except Exception:
                pass
            return

        y_cols = [self.y_listbox.get(i) for i in selected_indices]
        right_cols = [self.right_y_listbox.get(i) for i in right_indices]
        right2_cols = [self.right2_y_listbox.get(i) for i in right2_indices]

        # Gather labels from inline rows
        labels = []
        for i, col in enumerate(y_cols):
            label = col
            if i < len(self.line_properties_frames):
                try:
                    var = self.line_properties_frames[i]._linked_label_var
                    if var.get().strip():
                        label = var.get().strip()
                except Exception:
                    pass
            labels.append(label)

        right_labels = []
        for i, col in enumerate(right_cols):
            label = col
            if i < len(self.right_line_properties_frames):
                try:
                    var = self.right_line_properties_frames[i]._linked_label_var
                    if var.get().strip():
                        label = var.get().strip()
                except Exception:
                    pass
            right_labels.append(label)

        right2_labels = []
        for i, col in enumerate(right2_cols):
            label = col
            if i < len(self.right2_line_properties_frames):
                try:
                    var = self.right2_line_properties_frames[i]._linked_label_var
                    if var.get().strip():
                        label = var.get().strip()
                except Exception:
                    pass
            right2_labels.append(label)

        # Try to get requested figure size
        try:
            pw = float(self.plot_width.get())
            ph = float(self.plot_height.get())
        except Exception:
            pw = self.default_plot_width
            ph = self.default_plot_height

        # Decide whether to downsample: apply only when this is NOT an explicit request, downsample toggle is enabled,
        # and the dataframe is larger than the configured max points.
        n_rows = len(self.df.index) if self.df is not None else 0
        do_downsample = (not explicit) and self.downsample_live_var.get() and (n_rows > max(1, self.max_preview_points.get()))

        # Helper to get sampled x/y arrays
        def get_xy_arrays(col_name):
            # returns (x_arr, y_arr) either full or downsampled
            try:
                if do_downsample:
                    max_pts = max(1, int(self.max_preview_points.get()))
                    n = n_rows
                    # choose indices that are evenly spaced across the series
                    idx = np.linspace(0, n-1, num=min(n, max_pts), dtype=int)
                    x_arr = self.df[self.x_combo.get()].values[idx]
                    y_arr = self.df[col_name].values[idx].astype(float)
                    return x_arr, y_arr
                else:
                    x_arr = self.df[self.x_combo.get()].values
                    y_arr = (self.df[col_name].values.astype(float))
                    return x_arr, y_arr
            except Exception:
                # fallback to empty arrays if something goes wrong
                return np.array([]), np.array([])

        # Close previous figure and create new one
        plt.close(self.fig)
        # Check cancellation again before starting heavy drawing
        if self._preview_cancel_requested:
            self._preview_cancel_requested = False
            return
        self.fig, self.ax = plt.subplots(figsize=(pw, ph))

        # Use global line width
        try:
            global_lw = float(self.global_line_width.get())
        except Exception:
            global_lw = 1.0

        # Left Y-axis plotting
        for y_col, label, row in zip(y_cols, labels, self.line_properties_frames):
            if self._preview_cancel_requested:
                # abort early
                self._preview_cancel_requested = False
                try:
                    self.fig.clf()
                    self.canvas.draw()
                except Exception:
                    pass
                return
            try:
                lw = global_lw
            except Exception:
                lw = 1.0
            marker = None if (row.marker.get() == "None") else row.marker.get()
            try:
                x_arr, y_arr = get_xy_arrays(y_col)
                if x_arr.size == 0:
                    continue
                # determine marker color for this row: per-row marker_color if set else fall back to line color
                mcolor = getattr(row, "marker_color", "") or row.line_color
                self.ax.plot(
                    x_arr,
                    y_arr,
                    linestyle=row.line_style.get(),
                    linewidth=lw,
                    color=row.line_color,
                    marker=marker,
                    markersize=self.marker_size.get(),
                    markerfacecolor=mcolor,
                    markeredgecolor=mcolor,
                    label=label
                )
            except Exception:
                # If plotting a series errors (e.g., memory), skip and continue
                continue

        # Apply left axis coloring (spine, ticks, label)
        try:
            left_col = self.left_axis_color.get()
            self.ax.spines["left"].set_color(left_col)
            self.ax.yaxis.label.set_color(left_col)
            self.ax.tick_params(axis="y", colors=left_col)
        except Exception:
            pass

        # Right Y-axis 1
        ax2 = None
        if right_cols:
            ax2 = self.ax.twinx()
            for y_col, label, row in zip(right_cols, right_labels, self.right_line_properties_frames):
                if self._preview_cancel_requested:
                    self._preview_cancel_requested = False
                    try:
                        self.fig.clf()
                        self.canvas.draw()
                    except Exception:
                        pass
                    return
                try:
                    lw = global_lw
                except Exception:
                    lw = 1.0
                marker = None if (row.marker.get() == "None") else row.marker.get()
                try:
                    x_arr, y_arr = get_xy_arrays(y_col)
                    if x_arr.size == 0:
                        continue
                    mcolor = getattr(row, "marker_color", "") or row.line_color
                    ax2.plot(
                        x_arr,
                        y_arr,
                        linestyle=row.line_style.get(),
                        linewidth=lw,
                        color=row.line_color,
                        marker=marker,
                        markersize=self.marker_size.get(),
                        markerfacecolor=mcolor,
                        markeredgecolor=mcolor,
                        label=label
                    )
                except Exception:
                    continue
            # apply right axis coloring
            try:
                right_col = self.right_axis_color.get()
                ax2.spines["right"].set_color(right_col)
                ax2.yaxis.label.set_color(right_col)
                ax2.tick_params(axis="y", colors=right_col)
            except Exception:
                pass
            try:
                ax2.set_ylabel(self.right_ylabel_entry.get() or ", ".join(right_labels), fontsize=self.font_size.get())
            except Exception:
                pass

        # Right Y-axis 2 (additional axis)
        ax3 = None
        if right2_cols:
            ax3 = self.ax.twinx()
            # move the second right axis outward so it doesn't overlap with ax2
            try:
                pos = float(self.right2_pos.get())
                ax3.spines["right"].set_position(("axes", pos))
            except Exception:
                # fallback ignore
                pass
            try:
                ax3.set_frame_on(True)
            except Exception:
                pass

            for y_col, label, row in zip(right2_cols, right2_labels, self.right2_line_properties_frames):
                if self._preview_cancel_requested:
                    self._preview_cancel_requested = False
                    try:
                        self.fig.clf()
                        self.canvas.draw()
                    except Exception:
                        pass
                    return
                try:
                    lw = global_lw
                except Exception:
                    lw = 1.0
                marker = None if (row.marker.get() == "None") else row.marker.get()
                try:
                    x_arr, y_arr = get_xy_arrays(y_col)
                    if x_arr.size == 0:
                        continue
                    mcolor = getattr(row, "marker_color", "") or row.line_color
                    ax3.plot(
                        x_arr,
                        y_arr,
                        linestyle=row.line_style.get(),
                        linewidth=lw,
                        color=row.line_color,
                        marker=marker,
                        markersize=self.marker_size.get(),
                        markerfacecolor=mcolor,
                        markeredgecolor=mcolor,
                        label=label
                    )
                except Exception:
                    continue
            # apply right2 axis coloring
            try:
                right2_col = self.right2_axis_color.get()
                ax3.spines["right"].set_color(right2_col)
                ax3.yaxis.label.set_color(right2_col)
                ax3.tick_params(axis="y", colors=right2_col)
            except Exception:
                pass
            try:
                ax3.set_ylabel(self.right2_ylabel_entry.get() or ", ".join(right2_labels), fontsize=self.font_size.get())
            except Exception:
                pass

        # Apply axis limits and intervals
        try:
            xmin = float(self.xmin_entry.get()) if self.xmin_entry.get() else None
            xmax = float(self.xmax_entry.get()) if self.xmax_entry.get() else None
            ymin = float(self.ymin_entry.get()) if self.ymin_entry.get() else None
            ymax = float(self.ymax_entry.get()) if self.ymax_entry.get() else None
            self.ax.set_xlim(xmin, xmax)
            self.ax.set_ylim(ymin, ymax)
            if ax2:
                rymin = float(self.right_ymin_entry.get()) if self.right_ymin_entry.get() else None
                rymax = float(self.right_ymax_entry.get()) if self.right_ymax_entry.get() else None
                ax2.set_ylim(rymin, rymax)
            if ax3:
                ry2min = float(self.right2_ymin_entry.get()) if self.right2_ymin_entry.get() else None
                ry2max = float(self.right2_ymax_entry.get()) if self.right2_ymax_entry.get() else None
                ax3.set_ylim(ry2min, ry2max)
        except ValueError:
            pass

        try:
            # X-interval
            if self.xinterval_entry.get().strip() != "":
                xint = float(self.xinterval_entry.get())
                if xint > 0:
                    self.ax.xaxis.set_major_locator(MultipleLocator(xint))
            # Left Y-interval
            if self.yinterval_entry.get().strip() != "":
                yint = float(self.yinterval_entry.get())
                if yint > 0:
                    self.ax.yaxis.set_major_locator(MultipleLocator(yint))
            # Right Y-interval (ax2)
            if ax2 is not None and self.right_yinterval_entry.get().strip() != "":
                ryint = float(self.right_yinterval_entry.get())
                if ryint > 0:
                    ax2.yaxis.set_major_locator(MultipleLocator(ryint))
            # Right2 Y-interval (ax3)
            if ax3 is not None and self.right2_yinterval_entry.get().strip() != "":
                ry2int = float(self.right2_yinterval_entry.get())
                if ry2int > 0:
                    ax3.yaxis.set_major_locator(MultipleLocator(ry2int))
        except Exception:
            # ignore any parse errors and continue
            pass

        # --- Adjust subplot right margin so right-side axes are visible ---
        try:
            if ax3 is not None:
                right_margin = 0.70
            elif ax2 is not None:
                right_margin = 0.82
            else:
                right_margin = 0.92
            right_margin = max(0.5, min(0.95, right_margin))
            self.fig.subplots_adjust(right=right_margin)
        except Exception:
            pass

        # Labels & font
        fs = self.font_size.get()
        try:
            self.ax.set_title(self.title_entry.get(), fontsize=fs)
            self.ax.set_xlabel(self.xlabel_entry.get() or x_col, fontsize=fs)
            self.ax.set_ylabel(self.ylabel_entry.get() or ", ".join(labels), fontsize=fs)
            self.ax.tick_params(axis="both", labelsize=fs)
            if ax2:
                ax2.tick_params(axis="both", labelsize=fs)
            if ax3:
                ax3.tick_params(axis="both", labelsize=fs)
            if self.grid_var.get():
                self.ax.grid(True)
        except Exception:
            pass

        # Legends
        def place_legend(ax, legend_pos, cols, x_override=None, y_override=None):
            outside = False
            loc_map = {"outside top": "upper center",
                       "outside bottom": "lower center",
                       "outside left": "center left",
                       "outside right": "center right"}
            if legend_pos and legend_pos.startswith("outside"):
                outside = True
                loc = loc_map.get(legend_pos, "best")
            else:
                loc = legend_pos or "best"

            try:
                xo = float(x_override) if (x_override is not None and x_override != "") else None
                yo = float(y_override) if (y_override is not None and y_override != "") else None
            except Exception:
                xo = yo = None

            if xo is not None and yo is not None:
                ax.legend(loc=loc, bbox_to_anchor=(xo, yo), fontsize=fs, ncol=cols)
            elif outside:
                if "top" in legend_pos:
                    ax.legend(loc=loc, bbox_to_anchor=(0.5,1.15), fontsize=fs, ncol=cols)
                elif "bottom" in legend_pos:
                    ax.legend(loc=loc, bbox_to_anchor=(0.5,-0.3), fontsize=fs, ncol=cols)
                elif "left" in legend_pos:
                    ax.legend(loc=loc, bbox_to_anchor=(-0.3,0.5), fontsize=fs, ncol=cols)
                elif "right" in legend_pos:
                    ax.legend(loc=loc, bbox_to_anchor=(1.2,0.5), fontsize=fs, ncol=cols)
                else:
                    ax.legend(loc=loc, fontsize=fs, ncol=cols)
            else:
                ax.legend(loc=loc, fontsize=fs, ncol=cols)

        try:
            place_legend(self.ax, self.legend_loc_left.get(), self.legend_cols_left.get(), self.legend_x_left.get(), self.legend_y_left.get())
            if ax2:
                place_legend(ax2, self.legend_loc_right.get(), self.legend_cols_right.get(), self.legend_x_right.get(), self.legend_y_right.get())
            if ax3:
                place_legend(ax3, self.legend_loc_right2.get(), self.legend_cols_right2.get(), self.legend_x_right2.get(), self.legend_y_right2.get())
        except Exception:
            pass

        # Attach the new figure to the canvas and redraw
        try:
            self.canvas.figure = self.fig
            self.canvas.draw()
        except Exception:
            pass

    # ---------------- Save / Load configuration (add detected header index) ----------------
    def save_configuration(self):
        """
        Save editable text boxes and color/settings from all sections except:
        - "CSV File Selection"
        - Left/Right selections
        Saves detected_header_line_index as well.
        """
        config = {}
        # Labels & legend
        config['title'] = self.title_entry.get()
        config['xlabel'] = self.xlabel_entry.get()
        config['ylabel'] = self.ylabel_entry.get()
        config['right_ylabel'] = self.right_ylabel_entry.get()
        config['right2_ylabel'] = self.right2_ylabel_entry.get()

        config['legend_loc_left'] = self.legend_loc_left.get()
        config['legend_loc_right'] = self.legend_loc_right.get()
        config['legend_loc_right2'] = self.legend_loc_right2.get()
        config['legend_cols_left'] = int(self.legend_cols_left.get())
        config['legend_cols_right'] = int(self.legend_cols_right.get())
        config['legend_cols_right2'] = int(self.legend_cols_right2.get())
        config['legend_x_left'] = self.legend_x_left.get()
        config['legend_y_left'] = self.legend_y_left.get()
        config['legend_x_right'] = self.legend_x_right.get()
        config['legend_y_right'] = self.legend_y_right.get()
        config['legend_x_right2'] = self.legend_x_right2.get()
        config['legend_y_right2'] = self.legend_y_right2.get()

        config['font_size'] = int(self.font_size.get())
        config['show_grid'] = bool(self.grid_var.get())

        # preview/downsampling settings
        config['live_preview'] = bool(self.live_preview_var.get())
        config['downsample_live'] = bool(self.downsample_live_var.get())
        config['max_preview_points'] = int(self.max_preview_points.get())
        config['marker_size'] = float(self.marker_size.get())
        config['plot_width'] = float(self.plot_width.get())
        config['plot_height'] = float(self.plot_height.get())
        config['global_line_width'] = float(self.global_line_width.get())

        # axis colors (spine/ticks/labels)
        config['axis_colors'] = {
            'left': self.left_axis_color.get(),
            'right': self.right_axis_color.get(),
            'right2': self.right2_axis_color.get()
        }

        # Per-channel properties - left axis (use current frames to generate list)
        config['left_channel_props'] = []
        for row in self.line_properties_frames:
            try:
                entry = {
                    'col': getattr(row, "_col_name", ""),
                    'label': row._linked_label_var.get() if hasattr(row, "_linked_label_var") else "",
                    'line_color': getattr(row, 'line_color', ""),
                    'marker_color': getattr(row, 'marker_color', "") or "",
                    'style': row.line_style.get() if hasattr(row, 'line_style') else "",
                    'marker': row.marker.get() if hasattr(row, 'marker') else ""
                }
                config['left_channel_props'].append(entry)
            except Exception:
                continue

        # Per-channel properties - right axis 1
        config['right_channel_props'] = []
        for row in self.right_line_properties_frames:
            try:
                entry = {
                    'col': getattr(row, "_col_name", ""),
                    'label': row._linked_label_var.get() if hasattr(row, "_linked_label_var") else "",
                    'line_color': getattr(row, 'line_color', ""),
                    'marker_color': getattr(row, 'marker_color', "") or "",
                    'style': row.line_style.get() if hasattr(row, 'line_style') else "",
                    'marker': row.marker.get() if hasattr(row, 'marker') else ""
                }
                config['right_channel_props'].append(entry)
            except Exception:
                continue

        # Per-channel properties - right axis 2
        config['right2_channel_props'] = []
        for row in self.right2_line_properties_frames:
            try:
                entry = {
                    'col': getattr(row, "_col_name", ""),
                    'label': row._linked_label_var.get() if hasattr(row, "_linked_label_var") else "",
                    'line_color': getattr(row, 'line_color', ""),
                    'marker_color': getattr(row, 'marker_color', "") or "",
                    'style': row.line_style.get() if hasattr(row, 'line_style') else "",
                    'marker': row.marker.get() if hasattr(row, 'marker') else ""
                }
                config['right2_channel_props'].append(entry)
            except Exception:
                continue

        # Axis limits (save these too)
        config['axis_limits'] = {
            'xmin': self.xmin_entry.get(),
            'xmax': self.xmax_entry.get(),
            'ymin': self.ymin_entry.get(),
            'ymax': self.ymax_entry.get(),
            'right_ymin': self.right_ymin_entry.get(),
            'right_ymax': self.right_ymax_entry.get(),
            'right2_ymin': self.right2_ymin_entry.get(),
            'right2_ymax': self.right2_ymax_entry.get()
        }

        # Save detected header line index if present
        config['detected_header_line_index'] = self.detected_header_line_index

        # Prompt file to save
        default_name = f"csv_plotter_config_{datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')}.json"
        filepath = filedialog.asksaveasfilename(defaultextension=".json", initialfile=default_name,
                                                filetypes=[("JSON files", "*.json")])
        if not filepath:
            return
        try:
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(config, f, indent=2)
            messagebox.showinfo("Saved", f"Configuration saved to {filepath}")
        except Exception as e:
            messagebox.showerror("Save Error", str(e))

    def load_configuration(self):
        """
        Load a JSON configuration previously saved by save_configuration.
        Applies saved values to the UI widgets except:
         - CSV File Selection (file path)
         - Left Y-axis Selection (which columns are selected)
         - Right Y-axis 1 Selection
         - Right Y-axis 2 Selection
        Also restores detected_header_line_index if present.
        """
        path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json"), ("All files", "*.*")])
        if not path:
            return
        try:
            with open(path, "r", encoding="utf-8") as f:
                cfg = json.load(f)
        except Exception as e:
            messagebox.showerror("Load Error", f"Could not read configuration: {e}")
            return

        try:
            # Labels & legend
            self.title_entry.delete(0, "end"); self.title_entry.insert(0, cfg.get('title', ''))
            self.xlabel_entry.delete(0, "end"); self.xlabel_entry.insert(0, cfg.get('xlabel', ''))
            self.ylabel_entry.delete(0, "end"); self.ylabel_entry.insert(0, cfg.get('ylabel', ''))
            self.right_ylabel_entry.delete(0, "end"); self.right_ylabel_entry.insert(0, cfg.get('right_ylabel', ''))
            self.right2_ylabel_entry.delete(0, "end"); self.right2_ylabel_entry.insert(0, cfg.get('right2_ylabel', ''))

            # legend positions & cols
            self.legend_loc_left.set(cfg.get('legend_loc_left', self.legend_loc_left.get()))
            self.legend_loc_right.set(cfg.get('legend_loc_right', self.legend_loc_right.get()))
            self.legend_loc_right2.set(cfg.get('legend_loc_right2', self.legend_loc_right2.get()))
            try:
                self.legend_cols_left.set(cfg.get('legend_cols_left', self.legend_cols_left.get()))
                self.legend_cols_right.set(cfg.get('legend_cols_right', self.legend_cols_right.get()))
                self.legend_cols_right2.set(cfg.get('legend_cols_right2', self.legend_cols_right2.get()))
            except Exception:
                pass
            self.legend_x_left.set(cfg.get('legend_x_left', self.legend_x_left.get()))
            self.legend_y_left.set(cfg.get('legend_y_left', self.legend_y_left.get()))
            self.legend_x_right.set(cfg.get('legend_x_right', self.legend_x_right.get()))
            self.legend_y_right.set(cfg.get('legend_y_right', self.legend_y_right.get()))
            self.legend_x_right2.set(cfg.get('legend_x_right2', self.legend_x_right2.get()))
            self.legend_y_right2.set(cfg.get('legend_y_right2', self.legend_y_right2.get()))

            # font and grid
            try:
                self.font_size.set(cfg.get('font_size', self.font_size.get()))
            except Exception:
                pass
            self.grid_var.set(cfg.get('show_grid', bool(self.grid_var.get())))

            # preview/downsampling
            self.live_preview_var.set(cfg.get('live_preview', bool(self.live_preview_var.get())))
            self.downsample_live_var.set(cfg.get('downsample_live', bool(self.downsample_live_var.get())))
            try:
                self.max_preview_points.set(int(cfg.get('max_preview_points', self.max_preview_points.get())))
            except Exception:
                pass
            try:
                self.marker_size.set(float(cfg.get('marker_size', self.marker_size.get())))
            except Exception:
                pass
            try:
                self.plot_width.set(float(cfg.get('plot_width', self.plot_width.get())))
                self.plot_height.set(float(cfg.get('plot_height', self.plot_height.get())))
            except Exception:
                pass

            # global line width
            try:
                self.global_line_width.set(float(cfg.get('global_line_width', self.global_line_width.get())))
            except Exception:
                pass

            # axis colors
            axis_colors = cfg.get('axis_colors', {})
            if 'left' in axis_colors:
                self.left_axis_color.set(axis_colors['left'])
                try: self.left_axis_swatch.configure(background=axis_colors['left'])
                except Exception: pass
            if 'right' in axis_colors:
                self.right_axis_color.set(axis_colors['right'])
                try: self.right_axis_swatch.configure(background=axis_colors['right'])
                except Exception: pass
            if 'right2' in axis_colors:
                self.right2_axis_color.set(axis_colors['right2'])
                try: self.right2_axis_swatch.configure(background=axis_colors['right2'])
                except Exception: pass

            # axis limits
            axis_limits = cfg.get('axis_limits', {})
            for key, entry_widget in (('xmin', self.xmin_entry), ('xmax', self.xmax_entry),
                                      ('ymin', self.ymin_entry), ('ymax', self.ymax_entry),
                                      ('right_ymin', self.right_ymin_entry), ('right_ymax', self.right_ymax_entry),
                                      ('right2_ymin', self.right2_ymin_entry), ('right2_ymax', self.right2_ymax_entry)):
                try:
                    val = axis_limits.get(key, "")
                    entry_widget.delete(0, "end")
                    if val is not None:
                        entry_widget.insert(0, str(val))
                except Exception:
                    pass

            # If detected header index saved, restore it
            try:
                self.detected_header_line_index = cfg.get('detected_header_line_index', None)
            except Exception:
                self.detected_header_line_index = None

            # Per-channel props: apply in-order to existing rows (index-based) after building rows
            # We don't create rows here because selections are not saved; instead populate maps so that when user selects columns later
            # their properties can be applied. Read props lists and populate maps keyed by 'col' if present.
            try:
                self.left_channel_props.clear()
                for p in cfg.get('left_channel_props', []):
                    col = p.get('col') or p.get('label') or ""
                    if not col:
                        continue
                    self.left_channel_props[col] = {
                        "label": p.get('label', col),
                        "line_color": p.get('line_color', ""),
                        "marker_color": p.get('marker_color', "") or "",
                        "style": p.get('style', "-"),
                        "marker": p.get('marker', "None")
                    }
            except Exception:
                pass

            try:
                self.right_channel_props.clear()
                for p in cfg.get('right_channel_props', []):
                    col = p.get('col') or p.get('label') or ""
                    if not col:
                        continue
                    self.right_channel_props[col] = {
                        "label": p.get('label', col),
                        "line_color": p.get('line_color', ""),
                        "marker_color": p.get('marker_color', "") or "",
                        "style": p.get('style', "-"),
                        "marker": p.get('marker', "None")
                    }
            except Exception:
                pass

            try:
                self.right2_channel_props.clear()
                for p in cfg.get('right2_channel_props', []):
                    col = p.get('col') or p.get('label') or ""
                    if not col:
                        continue
                    self.right2_channel_props[col] = {
                        "label": p.get('label', col),
                        "line_color": p.get('line_color', ""),
                        "marker_color": p.get('marker_color', "") or "",
                        "style": p.get('style', "-"),
                        "marker": p.get('marker', "None")
                    }
            except Exception:
                pass

            # schedule preview to reflect loaded settings
            self.schedule_preview()
            messagebox.showinfo("Loaded", f"Configuration loaded from {path}")
        except Exception as e:
            messagebox.showerror("Load Error", f"Could not apply configuration: {e}")

    # ---------------- Save PNG (unchanged except use of current maps via frames) ----------------
    def save_png(self):
        if self.df is None:
            messagebox.showwarning("No plot", "Preview a plot first!")
            return

        filename = filedialog.asksaveasfilename(defaultextension=".png", filetypes=[("PNG files", "*.png")])
        if not filename:
            return

        # For saving, always render full-data figure (ignore downsampling)
        try:
            pw = float(self.plot_width.get())
            ph = float(self.plot_height.get())
        except Exception:
            pw = self.default_plot_width
            ph = self.default_plot_height

        # Build a fresh figure (full data)
        fig_save, ax_save = plt.subplots(figsize=(pw, ph))

        x_col = self.x_combo.get()
        selected_indices = self.y_listbox.curselection()
        right_indices = self.right_y_listbox.curselection()
        right2_indices = self.right2_y_listbox.curselection()

        y_cols = [self.y_listbox.get(i) for i in selected_indices]
        right_cols = [self.right_y_listbox.get(i) for i in right_indices]
        right2_cols = [self.right2_y_listbox.get(i) for i in right2_indices]

        try:
            global_lw = float(self.global_line_width.get())
        except Exception:
            global_lw = 1.0

        # left series
        for y_col, row in zip(y_cols, self.line_properties_frames):
            try:
                lw = global_lw
            except Exception:
                lw = 1.0
            marker = None if (row.marker.get() == "None") else row.marker.get()
            try:
                ydata = self.df[y_col].values.astype(float)
                mcolor = getattr(row, "marker_color", "") or row.line_color
                ax_save.plot(
                    self.df[x_col].values,
                    ydata,
                    linestyle=row.line_style.get(),
                    linewidth=lw,
                    color=row.line_color,
                    marker=marker,
                    markersize=self.marker_size.get(),
                    markerfacecolor=mcolor,
                    markeredgecolor=mcolor,
                    label=row._linked_label_var.get() if hasattr(row, "_linked_label_var") else y_col
                )
            except Exception:
                continue

        # apply left axis color
        try:
            left_col = self.left_axis_color.get()
            ax_save.spines["left"].set_color(left_col)
            ax_save.yaxis.label.set_color(left_col)
            ax_save.tick_params(axis="y", colors=left_col)
        except Exception:
            pass

        ax2_save = None
        if right_cols:
            ax2_save = ax_save.twinx()
            for y_col, row in zip(right_cols, self.right_line_properties_frames):
                try:
                    lw = global_lw
                except Exception:
                    lw = 1.0
                marker = None if (row.marker.get() == "None") else row.marker.get()
                try:
                    ydata = self.df[y_col].values.astype(float)
                    mcolor = getattr(row, "marker_color", "") or row.line_color
                    ax2_save.plot(
                        self.df[x_col].values,
                        ydata,
                        linestyle=row.line_style.get(),
                        linewidth=lw,
                        color=row.line_color,
                        marker=marker,
                        markersize=self.marker_size.get(),
                        markerfacecolor=mcolor,
                        markeredgecolor=mcolor,
                        label=row._linked_label_var.get() if hasattr(row, "_linked_label_var") else y_col
                    )
                except Exception:
                    continue
            # apply right axis color
            try:
                right_col = self.right_axis_color.get()
                ax2_save.spines["right"].set_color(right_col)
                ax2_save.yaxis.label.set_color(right_col)
                ax2_save.tick_params(axis="y", colors=right_col)
            except Exception:
                pass
            try:
                ax2_save.set_ylabel(self.right_ylabel_entry.get() or ", ".join([r._linked_label_var.get() if hasattr(r, "_linked_label_var") else "" for r in self.right_line_properties_frames]), fontsize=self.font_size.get())
            except Exception:
                pass

        ax3_save = None
        if right2_cols:
            ax3_save = ax_save.twinx()
            try:
                pos = float(self.right2_pos.get())
                ax3_save.spines["right"].set_position(("axes", pos))
            except Exception:
                pass
            for y_col, row in zip(right2_cols, self.right2_line_properties_frames):
                try:
                    lw = global_lw
                except Exception:
                    lw = 1.0
                marker = None if (row.marker.get() == "None") else row.marker.get()
                try:
                    ydata = self.df[y_col].values.astype(float)
                    mcolor = getattr(row, "marker_color", "") or row.line_color
                    ax3_save.plot(
                        self.df[x_col].values,
                        ydata,
                        linestyle=row.line_style.get(),
                        linewidth=lw,
                        color=row.line_color,
                        marker=marker,
                        markersize=self.marker_size.get(),
                        markerfacecolor=mcolor,
                        markeredgecolor=mcolor,
                        label=row._linked_label_var.get() if hasattr(row, "_linked_label_var") else y_col
                    )
                except Exception:
                    continue
            try:
                right2_col = self.right2_axis_color.get()
                ax3_save.spines["right"].set_color(right2_col)
                ax3_save.yaxis.label.set_color(right2_col)
                ax3_save.tick_params(axis="y", colors=right2_col)
            except Exception:
                pass
            try:
                ax3_save.set_ylabel(self.right2_ylabel_entry.get() or ", ".join([r._linked_label_var.get() if hasattr(r, "_linked_label_var") else "" for r in self.right2_line_properties_frames]), fontsize=self.font_size.get())
            except Exception:
                pass

        # Apply axis limits for save figure
        try:
            xmin = float(self.xmin_entry.get()) if self.xmin_entry.get() else None
            xmax = float(self.xmax_entry.get()) if self.xmax_entry.get() else None
            ymin = float(self.ymin_entry.get()) if self.ymin_entry.get() else None
            ymax = float(self.ymax_entry.get()) if self.ymax_entry.get() else None
            ax_save.set_xlim(xmin, xmax)
            ax_save.set_ylim(ymin, ymax)
            if ax2_save:
                rymin = float(self.right_ymin_entry.get()) if self.right_ymin_entry.get() else None
                rymax = float(self.right_ymax_entry.get()) if self.right_ymax_entry.get() else None
                ax2_save.set_ylim(rymin, rymax)
            if ax3_save:
                ry2min = float(self.right2_ymin_entry.get()) if self.right2_ymin_entry.get() else None
                ry2max = float(self.right2_ymax_entry.get()) if self.right2_ymax_entry.get() else None
                ax3_save.set_ylim(ry2min, ry2max)
        except Exception:
            pass

        # Apply interval tick spacing for save figure if provided
        try:
            if self.xinterval_entry.get().strip() != "":
                xint = float(self.xinterval_entry.get())
                if xint > 0:
                    ax_save.xaxis.set_major_locator(MultipleLocator(xint))
            if self.yinterval_entry.get().strip() != "":
                yint = float(self.yinterval_entry.get())
                if yint > 0:
                    ax_save.yaxis.set_major_locator(MultipleLocator(yint))
            if ax2_save is not None and self.right_yinterval_entry.get().strip() != "":
                ryint = float(self.right_yinterval_entry.get())
                if ryint > 0:
                    ax2_save.yaxis.set_major_locator(MultipleLocator(ryint))
            if ax3_save is not None and self.right2_yinterval_entry.get().strip() != "":
                ry2int = float(self.right2_yinterval_entry.get())
                if ry2int > 0:
                    ax3_save.yaxis.set_major_locator(MultipleLocator(ry2int))
        except Exception:
            pass

        # adjust subplot right margin for save figure similarly
        try:
            if ax3_save is not None:
                right_margin = 0.70
            elif ax2_save is not None:
                right_margin = 0.82
            else:
                right_margin = 0.92
            right_margin = max(0.5, min(0.95, right_margin))
            fig_save.subplots_adjust(right=right_margin)
        except Exception:
            pass

        # Labels & font for save figure
        fs = self.font_size.get()
        try:
            ax_save.set_title(self.title_entry.get(), fontsize=fs)
            ax_save.set_xlabel(self.xlabel_entry.get() or x_col, fontsize=fs)
            ax_save.set_ylabel(self.ylabel_entry.get() or ", ".join([r._linked_label_var.get() if hasattr(r, "_linked_label_var") else "" for r in self.line_properties_frames]), fontsize=fs)
            ax_save.tick_params(axis="both", labelsize=fs)
            if ax2_save:
                ax2_save.tick_params(axis="both", labelsize=fs)
            if ax3_save:
                ax3_save.tick_params(axis="both", labelsize=fs)
            if self.grid_var.get():
                ax_save.grid(True)
        except Exception:
            pass

        # Place legends for save figure
        def place_legend_save(ax, legend_pos, cols, x_override=None, y_override=None):
            outside = False
            loc_map = {"outside top": "upper center",
                       "outside bottom": "lower center",
                       "outside left": "center left",
                       "outside right": "center right"}
            if legend_pos and legend_pos.startswith("outside"):
                outside = True
                loc = loc_map.get(legend_pos, "best")
            else:
                loc = legend_pos or "best"

            try:
                xo = float(x_override) if (x_override is not None and x_override != "") else None
                yo = float(y_override) if (y_override is not None and y_override != "") else None
            except Exception:
                xo = yo = None

            if xo is not None and yo is not None:
                ax.legend(loc=loc, bbox_to_anchor=(xo, yo), fontsize=fs, ncol=cols)
            elif outside:
                if "top" in legend_pos:
                    ax.legend(loc=loc, bbox_to_anchor=(0.5,1.15), fontsize=fs, ncol=cols)
                elif "bottom" in legend_pos:
                    ax.legend(loc=loc, bbox_to_anchor=(0.5,-0.3), fontsize=fs, ncol=cols)
                elif "left" in legend_pos:
                    ax.legend(loc=loc, bbox_to_anchor=(-0.3,0.5), fontsize=fs, ncol=cols)
                elif "right" in legend_pos:
                    ax.legend(loc=loc, bbox_to_anchor=(1.2,0.5), fontsize=fs, ncol=cols)
                else:
                    ax.legend(loc=loc, fontsize=fs, ncol=cols)
            else:
                ax.legend(loc=loc, fontsize=fs, ncol=cols)

        try:
            place_legend_save(ax_save, self.legend_loc_left.get(), self.legend_cols_left.get(), self.legend_x_left.get(), self.legend_y_left.get())
            if ax2_save:
                place_legend_save(ax2_save, self.legend_loc_right.get(), self.legend_cols_right.get(), self.legend_x_right.get(), self.legend_y_right.get())
            if ax3_save:
                place_legend_save(ax3_save, self.legend_loc_right2.get(), self.legend_cols_right2.get(), self.legend_x_right2.get(), self.legend_y_right2.get())
        except Exception:
            pass

        # Save to file
        try:
            dpi = int(self.dpi_option.get())
        except Exception:
            dpi = 200
        try:
            fig_save.savefig(filename, dpi=dpi, bbox_inches="tight")
            plt.close(fig_save)
            messagebox.showinfo("Saved", f"Plot saved as {filename} at {dpi} DPI")
        except Exception as e:
            messagebox.showerror("Save Error", str(e))


if __name__ == "__main__":
    root = tk.Tk()
    root.geometry("1600x1000")  # wider by default so left column can be large
    app = CSVPlotter(root)
    root.mainloop()
